name: Dependabot Auto-merge

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: github.actor == 'dependabot[bot]'
    permissions:
      contents: write
      pull-requests: write
      issues: write
    
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        
      - name: Get PR details
        id: pr
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.issue.number
            });
            
            return {
              title: pr.title,
              body: pr.body,
              mergeable: pr.mergeable,
              mergeable_state: pr.mergeable_state,
              draft: pr.draft,
              labels: pr.labels.map(label => label.name)
            };
            
      - name: Check if auto-merge is safe
        id: safety-check
        run: |
          # Check if PR is from dependabot
          if [[ "${{ github.actor }}" != "dependabot[bot]" ]]; then
            echo "safe=false" >> $GITHUB_OUTPUT
            echo "reason=Not a dependabot PR" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if PR is draft
          if [[ "${{ steps.pr.outputs.draft }}" == "true" ]]; then
            echo "safe=false" >> $GITHUB_OUTPUT
            echo "reason=PR is in draft state" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Only block if explicitly dirty or blocked (be lenient with unknown/null states)
          if [[ "${{ steps.pr.outputs.mergeable_state }}" == "dirty" ]]; then
            echo "safe=false" >> $GITHUB_OUTPUT
            echo "reason=PR has merge conflicts" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          if [[ "${{ steps.pr.outputs.mergeable_state }}" == "blocked" ]]; then
            echo "safe=false" >> $GITHUB_OUTPUT
            echo "reason=PR is blocked" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Only block if explicitly false (not if null/undefined)
          if [[ "${{ steps.pr.outputs.mergeable }}" == "false" ]]; then
            echo "safe=false" >> $GITHUB_OUTPUT
            echo "reason=PR is not mergeable" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if it's a major version update (be more cautious)
          if echo "${{ steps.pr.outputs.title }}" | grep -E "Bump.*from [0-9]+\.0\.0 to [0-9]+\.0\.0"; then
            echo "safe=false" >> $GITHUB_OUTPUT
            echo "reason=Major version update detected" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Check if it's a breaking change
          if echo "${{ steps.pr.outputs.body }}" | grep -i "breaking change\|breaking changes"; then
            echo "safe=false" >> $GITHUB_OUTPUT
            echo "reason=Breaking changes detected" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "safe=true" >> $GITHUB_OUTPUT
          echo "reason=All safety checks passed" >> $GITHUB_OUTPUT
          
      - name: Wait for checks to complete
        if: steps.safety-check.outputs.safe == 'true'
        uses: lewagon/wait-on-check-action@v1.3.1
        with:
          ref: ${{ github.event.pull_request.head.sha }}
          check-name: 'Dependabot Auto-merge'
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 10
          allowed-conclusions: success,skipped,neutral
          
      - name: Auto-merge PR
        if: steps.safety-check.outputs.safe == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.issue.number;
            
            try {
              console.log(`üîÑ Attempting to merge PR #${prNumber}...`);
              
              const mergeResult = await github.rest.pulls.merge({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                merge_method: 'squash',
                commit_title: `${{ steps.pr.outputs.title }}`,
                commit_message: 'Auto-merged by Dependabot automation'
              });
              
              console.log(`‚úÖ Successfully merged PR #${prNumber}`);
              console.log(`Merge SHA: ${mergeResult.data.sha}`);
              
              // Delete the branch after successful merge
              try {
                const { data: pr } = await github.rest.pulls.get({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber
                });
                
                await github.rest.git.deleteRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${pr.head.ref}`
                });
                console.log(`üóëÔ∏è Deleted branch: ${pr.head.ref}`);
              } catch (deleteError) {
                console.log(`‚ö†Ô∏è Could not delete branch: ${deleteError.message}`);
              }
              
            } catch (error) {
              console.log(`‚ùå Failed to merge PR #${prNumber}: ${error.message}`);
              
              // Only close PRs that are truly unmergeable (not just conflicted)
              if (error.status === 422 && error.message.includes('not mergeable')) {
                console.log(`üîí Closing unmergeable PR #${prNumber} (truly cannot be merged)`);
                
                try {
                  await github.rest.pulls.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    pull_number: prNumber,
                    state: 'closed'
                  });
                  
                  // Delete the branch for truly unmergeable PRs
                  try {
                    const { data: pr } = await github.rest.pulls.get({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber
                    });
                    
                    await github.rest.git.deleteRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `heads/${pr.head.ref}`
                    });
                    console.log(`üóëÔ∏è Deleted branch: ${pr.head.ref}`);
                  } catch (deleteError) {
                    console.log(`‚ö†Ô∏è Could not delete branch: ${deleteError.message}`);
                  }
                } catch (closeError) {
                  console.log(`‚ö†Ô∏è Could not close PR: ${closeError.message}`);
                }
              } else {
                // For other errors (like conflicts), keep PR open for manual review
                console.log(`üìù Keeping PR #${prNumber} open for manual review`);
                console.log(`  ‚Üí Error: ${error.message}`);
                console.log(`  ‚Üí Status: ${error.status}`);
              }
            }
            
      - name: Comment on PR
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            let message;
            
            if ('${{ steps.safety-check.outputs.safe }}' === 'true') {
              // Check if PR was actually merged by looking at the logs
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: context.issue.number
              });
              
              if (pr.state === 'closed' && pr.merged_at) {
                message = '‚úÖ **Auto-merged successfully!** This PR has been automatically merged and the branch has been cleaned up.';
              } else if (pr.state === 'closed' && !pr.merged_at) {
                message = 'üîí **PR closed** - This PR was determined to be unmergeable and has been closed automatically.';
              } else {
                message = 'üìù **PR kept open for manual review** - This PR has conflicts or other issues that require manual attention. Please review and resolve conflicts if needed.';
              }
            } else {
              message = `‚ùå **Auto-merge skipped**: ${{ steps.safety-check.outputs.reason }}`;
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: message
            });
